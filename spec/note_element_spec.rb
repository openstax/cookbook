# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Kitchen::NoteElement do
  let(:book_with_valid_note) do
    book_containing(html:
      one_chapter_with_one_page_containing(
        <<~HTML
          <div data-type="note" id="noteId" class="chemistry link-to-learning">
            <p id="pId">Blah</p>
          </div>
        HTML
      ))
  end

  let(:book_with_note_bad_class) do
    book_containing(html:
      one_chapter_with_one_page_containing(
        <<~HTML
          <div data-type="note" id="noteId" class="bad-class">
            <p id="pId">Blah</p>
          </div>
        HTML
      ))
  end

  describe '#autogenerated_title' do
    before do
      stub_locales({
        'notes': {
          'link-to-learning': 'Chemistry',
          'everyday-life': 'Chemistry in Everyday Life'
        }
      })
    end

    context 'when lookup data is present' do
      let(:untitled_note) { book_with_valid_note.notes.first }

      it 'generates the note title' do
        expect(untitled_note.autogenerated_title).to eq 'Chemistry'
      end
    end

    context 'when the key "notes" does not exist in locales' do
      # overwrite current locales with blank hash
      before do
        stub_locales({})
      end

      let(:untitled_note) { book_with_valid_note.notes.first }

      it 'returns filler' do
        expect(untitled_note.autogenerated_title).to match(/unknown title for note with classes \[.*\]/)
      end
    end

    context 'when title for the given class does not exist in locales' do
      let(:unclassified_note) { book_with_note_bad_class.notes.first }

      it 'returns filler' do
        expect(unclassified_note.autogenerated_title).to match(/unknown title for note with classes \[.*\]/)
      end
    end
  end

  describe '#as_enumerator' do
    let(:untitled_note) { book_with_valid_note.notes.first }

    it 'can get its own enumerator' do
      expect(untitled_note.as_enumerator).to be_a Kitchen::NoteElementEnumerator
    end
  end

  describe '#title' do
    let(:notes_with_subtitle) do
      book_containing(html:
        one_chapter_with_one_page_containing(
          <<~HTML
            <div data-type="note">
              <div data-type="title">valid subtitle</div>
            </div>
            <div data-type="note">
              <div class="os-note-body">
                <div data-type="title">also valid subtitle</div>
              </div>
            </div>
            <div data-type="note">
              <div class="os-note-body">
                <p><div data-type="title">subtitles can be in a paragraph element</div></p>
              </div>
            </div>
          HTML
        )
      ).notes
    end

    let(:note_with_non_subtitle_title) do
      book_containing(html:
        one_chapter_with_one_page_containing(
          <<~HTML
            <div data-type="note">
              <p>some other content</p>
              <ul>
                <li><div data-type="title">not a subtitle</div></li>
              </ul>
            </div>
          HTML
        )
      ).notes.first
    end

    it 'gets the subtitle' do
      expect(notes_with_subtitle.first.title).to match_normalized_html('<div data-type="title">valid subtitle</div>')
      expect(notes_with_subtitle[1].title).to match_normalized_html('<div data-type="title">also valid subtitle</div>')
      expect(notes_with_subtitle[2].title).to match_normalized_html('<div data-type="title">subtitles can be in a paragraph element</div>')
    end

    it 'does not get non subtitle titles' do
      expect(note_with_non_subtitle_title.title).to eq(nil)
    end
  end

end

# frozen_string_literal: true

module Kitchen
  # An element for a note
  #
  class NoteElement < ElementBase

    # Creates a new +NoteElement+
    #
    # @param node [Nokogiri::XML::Node] the node this element wraps
    # @param document [Document] this element's document
    #
    def initialize(node:, document: nil)
      super(node: node,
            document: document,
            enumerator_class: NoteElementEnumerator)
    end

    # Returns the short type
    # @return [Symbol]
    #
    def self.short_type
      :note
    end

    # Returns the note's title element
    #
    # @return [Element, nil]
    #
    def title
      block_error_if(block_given?)
      # An element with data-type="title" is ambiguous; it is only the note's title if:
      # 1. it is the note body's first child
      # 2. it is the first child's first child and the first child is a paragraph
      first_child = first_note_body_child
      return unless first_child

      first_grandchild = get_first_grandchild_for_title(first_child)

      if first_child.data_type == 'title'
        first_child
      elsif first_grandchild&.data_type == 'title'
        first_grandchild
      end
    end

    def first_note_body_child
      note_body = first('div.os-note-body')
      note_body ? note_body.element_children[0] : element_children[0]
    end

    def get_first_grandchild_for_title(first_child)
      first_child&.element_children&.[](0) if first_child.name == 'p'
    end

    # Returns true if the note's title is autogenerated
    #
    # @return [Boolean]
    #
    def indicates_autogenerated_title?
      detected_note_title_key != 0 && detected_note_title_key.present?
    end

    # Get the autogenerated title for this note
    #
    # @return [String]
    #
    def autogenerated_title
      if indicates_autogenerated_title?
        I18n.t(:"notes.#{detected_note_title_key}")
      else
        "unknown title for note with classes #{classes}"
      end
    end

    protected

    def detected_note_title_key
      @detected_note_title_key ||= begin
        return 0 if classes.empty? || !I18n.t('.').key?(:notes)

        possible_keys = I18n.t(:notes).keys.map(&:to_s)
        keys = possible_keys & classes

        raise("too many translation keys: #{keys.join(', ')}") if keys.many?
        return 0 if keys.empty?

        keys.first
      end
    end
  end
end
